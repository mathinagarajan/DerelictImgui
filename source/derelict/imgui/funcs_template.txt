/*
 * Copyright (c) 2017 Derelict Developers
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *
 * * Neither the names 'Derelict', 'DerelictImgui', nor the names of its contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
module derelict.imgui.funcs;

/* generated by:
from mako.template import Template
print(Template(filename='funcs_template.txt').render())
open("imgui.d", "wb").write(Template(filename='funcs_template.txt').render().encode('utf-8'))
*/

private
{
    import derelict.util.system;
    import core.stdc.stdarg:va_list;
}

<%!
  import json
  functions = json.load(open('../../../cimgui/generator/output/definitions.json'))
  functions = {fname: function for fname, function in functions.items() if 'destructor' not in function[0] and 'constructor' not in function[0]}
  functions = {fname: function for fname, function in functions.items() if function[0]['argsoriginal'].find('ImVector') == -1}
  import re
  def adjust_args(args):
    args = args.replace('((void *)0)','null')
    args = re.sub('const char\* const (\w*)\[\]', 'const char** \g<1>', args)
    args = re.sub('(\w*)&', '\g<1>', args)
    args = re.sub(' in(\W)', ' in_\g<1>', args)
    args = re.sub(' ref(\W)', ' ref_\g<1>', args)
    args = re.sub('unsigned char', 'char', args)
    args = re.sub('unsigned int', 'uint', args)
    args = re.sub('float (\w*)\[(\d*)\]', 'float[\g<2>] \g<1>', args)
    args = re.sub('int (\w*)\[(\d*)\]', 'int[\g<2>] \g<1>', args)
    args = re.sub('ImVec2 (\w*)\[(\d*)\]', 'ImVec2[\g<2>] \g<1>', args)
    args = re.sub('sizeof\(float\)', '4', args)
    args = args.replace('void*(*alloc_func)(size_t sz,void* user_data)', 'ImGuiAllocFunc')
    args = args.replace('void(*free_func)(void* ptr,void* user_data)', 'ImGuiFreeFunc')

    return args

  typedefs = json.load(open('../../../cimgui/generator/output/typedefs_dict.json'))
  typedefs = {tname: tp for tname, tp in typedefs.items() if tp[0:6] != 'struct' and tp != 'T' and tp != 'const value_type*' and tp != 'value_type*' and tp[-1] != ';'}
  def adjust_typedef(tp):
    tp = tp.replace('unsigned char', 'char')
    tp = tp.replace('unsigned ', 'u')
    tp = tp.replace('signed ', '')
    tp = tp.replace('int64_t', 'long')
    tp = tp.replace('const char*(*)(void* user_data)', 'GetClipboardTextFunc')
    tp = tp.replace('void(*)(void* user_data,const char* text)', 'SetClipboardTextFunc')
    tp = tp.replace('void(*)(int x,int y)', 'ImeSetInputScreenPosFunc')

    return tp

  structs_and_enums = json.load(open('../../../cimgui/generator/output/structs_and_enums.json'))
  enums = structs_and_enums['enums']
  structs = structs_and_enums['structs']
  structs.pop('ImVector', None)
  vector_types = {}
  for sname, sfields in structs.items():
    for field in sfields:
      if 'template_type' not in field:
        continue
      vector_types[field['type']] = field['template_type']

  def get_struct_field(t, n):
    fstr = adjust_typedef(t) + ' ' + n
    fstr = re.sub('(.*) (.*)\[(.*)\]', '\g<1>[\g<3>] \g<2>', fstr)
    return fstr
%>

% for tname, tp in typedefs.items():
alias ${tname.ljust(20,' ')} = ${adjust_typedef(tp)};
% endfor
// special internal alias
alias ImDrawListSharedData = void;
alias ImGuiContext = void;

% for _, enum_list in enums.items():
enum {
%   for enum_value in enum_list:
    ${enum_value['name'].ljust(50,' ')} = ${enum_value['value']},
%   endfor
}

% endfor

struct ImVector(T)
{
    int                         Size;
    int                         Capacity;
    T*                          Data;
}

% for vector_alias, vt in vector_types.items():
alias ${vector_alias} = ImVector!(${adjust_typedef(vt)});
% endfor

% for sname, sfields in structs.items():
struct ${sname}
{
%   for field in sfields:
    ${get_struct_field(field['type'], field['name'])};
%   endfor
}
% endfor

extern(C) @nogc nothrow
{
    alias ImGuiAllocFunc = void* function(size_t sz, void* user_data);
	alias ImGuiFreeFunc = void function(void* ptr, void* user_data);
	alias ImGuiSizeCallback = void function(ImGuiSizeCallbackData* data);
	alias ImGuiInputTextCallback = int function(ImGuiInputTextCallbackData *data);
	alias ImDrawCallback = void function(const ImDrawList* parent_list,const ImDrawCmd* cmd);
	alias GetClipboardTextFunc = const char* function(void* user_data);
	alias SetClipboardTextFunc = void function(void* user_data,const char* text);
	alias ImeSetInputScreenPosFunc = void function(int x,int y);
}

extern(C) @nogc nothrow
{
% for fname, function in functions.items():
    alias da_${fname} = ${function[0]['ret']} function${adjust_args(function[0]['argsoriginal'])};
% endfor
}

__gshared
{
% for fname, function in functions.items():
	da_${fname} ${fname};
% endfor
}


private
{
    import derelict.util.loader;

    version(darwin)
        version = MacOSX;
    version(OSX)
        version = MacOSX;
}

private
{
    import derelict.util.loader;
    import derelict.util.system;

    static if(Derelict_OS_Windows)
        enum libNames = "cimgui.dll";
    else static if (Derelict_OS_Mac)
        enum libNames = "cimgui.dylib";
    else static if (Derelict_OS_Linux)
        enum libNames = "cimgui.so";
    else
        static assert(0, "Need to implement imgui libNames for this operating system.");
}

final class DerelictImguiLoader : SharedLibLoader
{
    protected
    {
        override void loadSymbols()
        {
% for fname, function in functions.items():
			bindFunc(cast(void**)&${fname}, "${fname}");
% endfor
		}
    }

    public
    {
        this()
        {
            super(libNames);
        }
    }
}

__gshared DerelictImguiLoader DerelictImgui;

shared static this()
{
    DerelictImgui = new DerelictImguiLoader();
}
