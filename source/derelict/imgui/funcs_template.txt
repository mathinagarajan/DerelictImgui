/*
 * Copyright (c) 2017 Derelict Developers
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *
 * * Neither the names 'Derelict', 'DerelictImgui', nor the names of its contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
module derelict.imgui.funcs;

/* generated by:
from mako.template import Template
print(Template(filename='funcs_template.txt').render())
open("imgui.d", "wb").write(Template(filename='funcs_template.txt').render().encode('utf-8'))
*/

private
{
    import derelict.util.system;
    import core.stdc.stdarg:va_list;
}

// Helpers macros to generate 32-bits encoded colors
version(IMGUI_USE_BGRA_PACKED_COLOR) {
    enum IM_COL32_R_SHIFT    = 16;
    enum IM_COL32_G_SHIFT    = 8;
    enum IM_COL32_B_SHIFT    = 0;
    enum IM_COL32_A_SHIFT    = 24;
    enum IM_COL32_A_MASK     = 0xFF000000;
} else {
    enum IM_COL32_R_SHIFT    = 0;
    enum IM_COL32_G_SHIFT    = 8;
    enum IM_COL32_B_SHIFT    = 16;
    enum IM_COL32_A_SHIFT    = 24;
    enum IM_COL32_A_MASK     = 0xFF000000;
}
uint IM_COL32(ubyte R, ubyte G, ubyte B, ubyte A = 255) {
    return (
            (cast(ImU32)(A)<<IM_COL32_A_SHIFT) | 
            (cast(ImU32)(B)<<IM_COL32_B_SHIFT) | 
            (cast(ImU32)(G)<<IM_COL32_G_SHIFT) | 
            (cast(ImU32)(R)<<IM_COL32_R_SHIFT)
            );
}
@property uint IM_COL32_WHITE() {
    return IM_COL32(255,255,255,255);   // Opaque white = 0xFFFFFFFF
}
@property uint IM_COL32_BLACK() {
    return IM_COL32(0,0,0,255);         // Opaque black
}
@property uint IM_COL32_BLACK_TRANS() {
    return IM_COL32(0,0,0,0);           // Transparent black = 0x00000000
}

<%!
  import json
  functionsWide = json.load(open('../../../cimgui/generator/output/definitions.json'))
  functions = {}
  for _, function_list in functionsWide.items():
    for function in function_list:
      fname = function.get('ov_cimguiname', function['cimguiname'])
      if "_nonUDT" in fname:
        continue
      if 'destructor' in function:
        function['funcname'] = 'destroy'
        function['ret'] = 'void'
      if 'constructor' in function:
        function['ret'] = function['stname'] + '*'
      if fname == 'igColorConvertRGBtoHSV' or fname == 'igColorConvertHSVtoRGB':
        function['args'] = function['args'].replace('float out', 'float* out')
      functions[fname] = function

  import re
  def adjust_args(args, defaults):
    args = args.replace('((void *)0)','null')
    args = re.sub('const char\* const (\w*)\[\]', 'const char** \g<1>', args)
    args = re.sub('(\w*)&', '\g<1>', args)
    args = re.sub(' in(\W)', ' in_\g<1>', args)
    args = re.sub(' ref(\W)', ' ref_\g<1>', args)
    args = re.sub(' out(\W)', ' out_\g<1>', args)
    args = re.sub('unsigned char', 'char', args)
    args = re.sub('unsigned int', 'uint', args)
    args = re.sub('float (\w*)\[(\d*)\]', 'float[\g<2>] \g<1>', args)
    args = re.sub('int (\w*)\[(\d*)\]', 'int[\g<2>] \g<1>', args)
    args = re.sub('ImVec2 (\w*)\[(\d*)\]', 'ImVec2[\g<2>] \g<1>', args)
    args = re.sub('sizeof\(float\)', '4', args)
    args = args.replace('void*(*alloc_func)(size_t sz,void* user_data)', 'ImGuiAllocFunc')
    args = args.replace('void(*free_func)(void* ptr,void* user_data)', 'ImGuiFreeFunc')
    args = args.replace('bool(*items_getter)(void* data,int idx,const char** out_text)', 'ImGuiItemGetter getter')
    args = args.replace('float(*values_getter)(void* data,int idx)', 'ImGuiValuesGetter getter')

    if len(defaults) > 0:
        for argname, argvalue in defaults.items():
            argvalue = argvalue.replace('((void *)0)', 'null')
            argvalue = argvalue.replace('FLT_MAX', 'float.max')
            argvalue = argvalue.replace('sizeof(float)', 'float.sizeof')
            args = re.sub(' ' + argname + '(\W)', ' ' + argname + ' = ' + argvalue + '\g<1>', args)

    return args

  typedefs = json.load(open('../../../cimgui/generator/output/typedefs_dict.json'))
  typedefs = {tname: tp for tname, tp in typedefs.items() if tp[0:6] != 'struct' and tp != 'T' and tp != 'const value_type*' and tp != 'value_type*' and tp[-1] != ';'}
  def adjust_typedef(tp):
    tp = tp.replace('unsigned char', 'char')
    tp = tp.replace('unsigned ', 'u')
    tp = tp.replace('signed ', '')
    tp = tp.replace('int64_t', 'long')
    tp = tp.replace('const char*(*)(void* user_data)', 'GetClipboardTextFunc')
    tp = tp.replace('void(*)(void* user_data,const char* text)', 'SetClipboardTextFunc')
    tp = tp.replace('void(*)(int x,int y)', 'ImeSetInputScreenPosFunc')
    tp = re.sub('const (\w*)', 'const(\g<1>)', tp)

    return tp

  def strip_self(str):
    index = str.find(' self,')
    return '('+str[index+6:]

  structs_and_enums = json.load(open('../../../cimgui/generator/output/structs_and_enums.json'))
  enums = structs_and_enums['enums']
  structs = structs_and_enums['structs']
  structs.pop('ImVector', None)
  vector_types = {}
  for sname, sfields in structs.items():
    for field in sfields:
      if 'template_type' not in field:
        continue
      vector_types[field['type']] = field['template_type']

  def get_struct_field(t, n):
    fstr = adjust_typedef(t) + ' ' + n
    fstr = re.sub('(.*) (.*)\[(.*)\]', '\g<1>[\g<3>] \g<2>', fstr)
    return fstr

  def adjust_callargs(callargs):
    if len(callargs) == 2:
      return '(this)'
    return '(this, ' + callargs[1:-1] + ')'

  def get_struct_functions(sname, functions):
    return {fname: function for fname, function in functions.items() if function.get('stname', 0) == sname}
%>

% for tname, tp in typedefs.items():
alias ${tname.ljust(20,' ')} = ${adjust_typedef(tp)};
% endfor
// special internal alias
alias ImDrawListSharedData = void;
alias ImGuiContext = void;

% for _, enum_list in enums.items():
enum {
%   for enum_value in enum_list:
    ${enum_value['name'].ljust(50,' ')} = ${enum_value['value']},
%   endfor
}

% endfor

struct ImVector(T)
{
    int                         Size = 0;
    int                         Capacity = 0;
    T*                          Data = null;

    ~this()
    {
        import core.stdc.stdlib;
        if (Data !is null) free(Data);
    }
    this(this)
    {
        reserve(Capacity);
    }
    void clear()
    {
        Size = 0;
    }
    void reserve(int newcap)
    {
        import core.stdc.stdlib;
        import std.algorithm;
        T* newData = cast(T*)(malloc(T.sizeof * newcap));
        auto copysize = min(newcap, Size);
        newData[0..copysize] = Data[0..copysize];
        newData[copysize..newcap] = T();
        Data = newData;
        Size = copysize;
        Capacity = newcap;
    }
    void resize(int newsize)
    {
        if (newsize > Capacity) 
            reserve(newsize);
        if (newsize < Capacity)
            Data[Size..newsize] = T();
        Size = newsize;
    }
    void push_back(ref T item)
    {
        if (Size >= Capacity)
            reserve(Size + 32);
        range()[Size++] = item;
    }
    T pop_back()
    {
        return range()[--Size];
    }
    T[] range() { return Data[0..Size]; }
    const(T[]) range() const { return Data[0..Size]; }
    ref T opIndex(int index) {
        return range()[index];
    }
    ref const(T) opIndex(int index) const {
        return range()[index];
    }
}

% for vector_alias, vt in vector_types.items():
alias ${vector_alias} = ImVector!(${adjust_typedef(vt)});
% endfor

% for sname, sfields in structs.items():
struct ${sname}
{
%   for field in sfields:
    ${get_struct_field(field['type'], field['name'])};
%   endfor

% for fname, function in get_struct_functions(sname, functions).items():
//    alias ${fname[len(sname)+1:]} = ${fname};
<% retstr = '' if function['ret'] == 'void' else 'return ' %>
% if '* self' in function['args']:
    ${adjust_typedef(function['ret'])} ${fname[len(sname)+1:].replace(sname, 'from')}(A...)(A a) { ${retstr}${fname}(&this, a); }
% else:
    static ${adjust_typedef(function['ret'])} ${fname[len(sname)+1:].replace(sname, 'from')}(A...)(A a) { ${retstr}${fname}(a); }
% endif
//    ${adjust_typedef(function['ret'])} ${fname[len(sname)+1:]}${adjust_args(function['args'],function['defaults']).replace(sname + '* self,','').replace(sname + '* self','')} { ${retstr}${fname}(this, ${function['call_args'][1:-1]}); }
% endfor
}

% endfor

extern(C) nothrow
{
    alias ImGuiAllocFunc = void* function(size_t sz, void* user_data);
	alias ImGuiFreeFunc = void function(void* ptr, void* user_data);
	alias ImGuiSizeCallback = void function(ImGuiSizeCallbackData* data);
	alias ImGuiInputTextCallback = int function(ImGuiInputTextCallbackData *data);
	alias ImDrawCallback = void function(const ImDrawList* parent_list,const ImDrawCmd* cmd);
	alias GetClipboardTextFunc = const(char)* function(void* user_data);
	alias SetClipboardTextFunc = void function(void* user_data,const char* text);
	alias ImeSetInputScreenPosFunc = void function(int x,int y);

	alias ImGuiItemGetter = bool function(void* data,int idx,const char** out_text);
	alias ImGuiValuesGetter = float function(void* data,int idx);
}

extern(C) @nogc nothrow
{
% for fname, function in functions.items():
    alias da_${fname} = ${adjust_typedef(function['ret'])} function${adjust_args(function['args'],function['defaults'])};
% endfor
}

__gshared
{
% for fname, function in functions.items():
	da_${fname} ${fname};
% endfor
}


private
{
    import derelict.util.loader;

    version(darwin)
        version = MacOSX;
    version(OSX)
        version = MacOSX;
}

private
{
    import derelict.util.loader;
    import derelict.util.system;

    static if(Derelict_OS_Windows)
        enum libNames = "cimgui.dll";
    else static if (Derelict_OS_Mac)
        enum libNames = "cimgui.dylib";
    else static if (Derelict_OS_Linux)
        enum libNames = "cimgui.so";
    else
        static assert(0, "Need to implement imgui libNames for this operating system.");
}

final class DerelictImguiLoader : SharedLibLoader
{
    protected
    {
        override void loadSymbols()
        {
% for fname, function in functions.items():
			bindFunc(cast(void**)&${fname}, "${fname}");
% endfor
		}
    }

    public
    {
        this()
        {
            super(libNames);
        }
    }
}

__gshared DerelictImguiLoader DerelictImgui;

shared static this()
{
    DerelictImgui = new DerelictImguiLoader();
}
